# Voboost Config - Project Intelligence

## Global Rules (CRITICAL)
- This project follows ALL common rules from ../voboost-codestyle/.clinerules
- The rules below are PROJECT-SPECIFIC additions to the global rules
- NEVER duplicate global rules here - they are inherited automatically

## Project-Specific Patterns

### File Structure
- Library code in src/main/java/ru/voboost/config/
- Demo app available as separate voboost-config-demo project in ../voboost-config-demo/ directory

### Testing Approach
- Mock Context for Android-specific operations
- Aim for 100% coverage of public API

## Critical Implementation Details (Project-Specific)

### ConfigManager Pattern
- Stateless facade pattern with comprehensive API
- Context-aware file operations using Android Context
- File watching with Hoplite Watch (NEVER use Java FileWatch)
- Diff calculation using reflection on Config fields
- Integrated diff utilities: isFieldChanged, getFieldValue, isValidConfig

### Diff Utilities Integration
- Refactored from demo project ConfigDiffUtils into main library
- All functionality now available through ConfigManager
- Reflection-based field access using dot notation paths
- Type-safe operations with proper error handling

### YAML Integration
- Hoplite library for parsing and serialization
- All Config properties nullable for partial configurations

## Build System (Project-Specific)
- Multi-module project with library + demo app
- Android Gradle Plugin 8.2.0
- Kotlin 1.9.20
- Minimum API 28 (Android 9)
- Hoplite 2.9.0 for YAML processing

## Project Status
- COMPLETE and PRODUCTION READY
- All 33+ unit tests passing
- Demo application available as separate voboost-config-demo project
- Comprehensive documentation complete
- Ready for external use

## Key Success Factors
- Extended public API (comprehensive ConfigManager with utilities)
- Type-safe configuration access
- Real-time change detection with error callbacks
- Android-optimized file operations
- Comprehensive error handling with Result pattern
- Zero memory leaks in file watching
- Callback-based change notifications for reactive programming
- Universal reflection for extensibility

## Configuration Structure Rules (CRITICAL)
- NEVER use @ConfigAlias annotations - they are NOT needed and should not be used
- Config structure is completely FLAT - no nested objects
- YAML structure is also FLAT with kebab-case keys (settings-language, vehicle-fuel-mode, etc.)
- Kotlin field names map directly to YAML keys using kebab-case conversion
- Example: settingsLanguage -> settings-language, vehicleFuelMode -> vehicle-fuel-mode
- This flat structure simplifies reflection and eliminates annotation complexity

## Reflection and Field Access Rules (CRITICAL)
- ALL methods in ConfigManager MUST use recursive reflection instead of direct field access
- NEVER use Any type - always use Config type for type safety
- Direct field access is ONLY allowed in convertConfigToYaml method for clean YAML output
- createDiff method MUST use recursive object traversal for universal field comparison
- isFieldChanged method MUST use recursive reflection through getValueByPath
- isValidConfig method MUST use recursive validation through validateObjectRecursively
- getValueByPath method MUST work with Config type and handle any depth of nested fields
- All reflection-based methods must be universal and extensible for any number of fields
- These rules ensure the code is maintainable and works with any configuration structure

## Validation Rules (CRITICAL)
- ALL fields in Config are required when loaded from filesystem (including Int fields)
- validateObjectRecursively must check that ALL fields are non-null
- This ensures complete configuration when reading from YAML files
